/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. LolParser.jj */
/*@egen*//**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **\
|   The_Almost_Donerz : CS 153 Compiler Design   |
|   				 Fall 2014                   |
\**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/

options
{
               
              
  DEBUG_PARSER=false;
                                                   
}

PARSER_BEGIN(LolParser)
package lolparser.frontend;

import java.io.FileReader;
import java.io.FileNotFoundException;

public class LolParser/*@bgen(jjtree)*/implements LolParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTLolParserState jjtree = new JJTLolParserState();

/*@egen*/
  public static void main(String args [])
  {
    try
    {  
	    if(args.length >= 1) {
			System.out.println("Reading from file: " +args[0]);
			new LolParser(new FileReader(args[0]));
	    } else {
			System.out.println("Reading from standard input...");
			new LolParser(System.in);
	    }
	} catch (FileNotFoundException fnfe) {
		System.out.println(args[0] + " was not able to be found.");
	}
    
    try
    {
      System.out.printf("/--- Parsing %s ---\\\n", args[0]); 
      SimpleNode n = LolParser.parse();
      n.dump("");
      System.out.println("---Finished Parsing!---");
    }
    catch (ParseException pe)    {
      pe.printStackTrace();    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
  }
}
PARSER_END(LolParser)

SimpleNode parse() :{/*@bgen(jjtree) parse */
  SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) parse */
  try {
/*@egen*/
  < HAI >(<EOL>)*
   (Statement())*
  < KTHXBYE > (<EOL>)*
  < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { return jjtn000;}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void Block()      :{}
{
 (LOOKAHEAD(2) Statement())+  
}

void Statement()     :{}
{
  Expression() 
}
void Expression()      :{}
{
  AssignmentExpression()
| FlowControlExpression() 
| ArithemticExpression()
| VarDeclareExpression()
| ConstLiteralExpression()
}

void ConstLiteralExpression()      :{}
{
  < QUOTED_STRING >
| < INTEGER >
}

void AssignmentExpression():{/*@bgen(jjtree) AssignmentExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AssignmentExpression */
  try {
/*@egen*/
  <IDENT> "R" Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void VarDeclareExpression():{/*@bgen(jjtree) VarDeclareExpression */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLAREEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDeclareExpression */
  try {
/*@egen*/
  <I> <HAS> <A> <IDENT> (<ITZ> ConstLiteralExpression())?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void FlowControlExpression()      :{}
{
  loop()
| ifThen()
}

// vvv Arithemic Operations vvv \\
void ArithemticExpression()      :{}
{
  SUM() 	// Add
| DIFF() 	// Subtract
| PRODUKT() // Product
| QUOSHUNT()// Quotient
| MOD() 	// Modulus
| BIGGR() 	// Max
| SMALLR() 	// Min
| UP()      // Increment
}
void SUM():  	// Add
{/*@bgen(jjtree) SUM */
  SimpleNode jjtn000 = new SimpleNode(JJTSUM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) SUM */
        try {
/*@egen*/
	<SUM> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void DIFF(): {/*@bgen(jjtree) DIFF */
  SimpleNode jjtn000 = new SimpleNode(JJTDIFF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Subtract
{/*@bgen(jjtree) DIFF */
  try {
/*@egen*/
  <DIFF> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/	
}
void PRODUKT(): {/*@bgen(jjtree) PRODUKT */
  SimpleNode jjtn000 = new SimpleNode(JJTPRODUKT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Product
{/*@bgen(jjtree) PRODUKT */
        try {
/*@egen*/
	<PRODUKT> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void QUOSHUNT(): {/*@bgen(jjtree) QUOSHUNT */
  SimpleNode jjtn000 = new SimpleNode(JJTQUOSHUNT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Quotient
{/*@bgen(jjtree) QUOSHUNT */
  try {
/*@egen*/
  <QUOSHUNT> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/	
}
void MOD(): {/*@bgen(jjtree) MOD */
  SimpleNode jjtn000 = new SimpleNode(JJTMOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Modulous
{/*@bgen(jjtree) MOD */
        try {
/*@egen*/
	<MOD> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void BIGGR(): {/*@bgen(jjtree) BIGGR */
  SimpleNode jjtn000 = new SimpleNode(JJTBIGGR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Max
{/*@bgen(jjtree) BIGGR */
        try {
/*@egen*/
	<BIGGR> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void SMALLR(): {/*@bgen(jjtree) SMALLR */
  SimpleNode jjtn000 = new SimpleNode(JJTSMALLR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Min
{/*@bgen(jjtree) SMALLR */
        try {
/*@egen*/
	<SMALLR> <OF> <INTEGER> <AN> <INTEGER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
void UP():{/*@bgen(jjtree) UP */
  SimpleNode jjtn000 = new SimpleNode(JJTUP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) UP */
    try {
/*@egen*/
    <UP> <IDENT> <BANG> <INTEGER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
// ^^^ Arithemic Expressions ^^^ \\



// vvv Boolean Expressions vvv \\
void BooleanOperation():{/*@bgen(jjtree) BooleanOperation */
  SimpleNode jjtn000 = new SimpleNode(JJTBOOLEANOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BooleanOperation */
  try {
/*@egen*/
  BOTH()   // And
| EITHER() // Or
| WON()    // Xor
| NOT()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/    // Not	
}
void BOTH():{/*@bgen(jjtree) BOTH */
  SimpleNode jjtn000 = new SimpleNode(JJTBOTH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // And
{/*@bgen(jjtree) BOTH */
  try {
/*@egen*/
  <BOTH> <OF> Expression() (<AN>)? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void EITHER():{/*@bgen(jjtree) EITHER */
  SimpleNode jjtn000 = new SimpleNode(JJTEITHER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Or
{/*@bgen(jjtree) EITHER */
  try {
/*@egen*/
  <EITHER> <OF> Expression() (<AN>)? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void WON():{/*@bgen(jjtree) WON */
  SimpleNode jjtn000 = new SimpleNode(JJTWON);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Xor
{/*@bgen(jjtree) WON */
  try {
/*@egen*/
  <WON> <OF> Expression() (<AN>)? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void NOT():{/*@bgen(jjtree) NOT */
  SimpleNode jjtn000 = new SimpleNode(JJTNOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} // Not
{/*@bgen(jjtree) NOT */
  try {
/*@egen*/
  <NOT> Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
// ^^^ Boolean Expressions ^^^ \\

void ComparisionOperation():{/*@bgen(jjtree) ComparisionOperation */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPARISIONOPERATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ComparisionOperation */
  try {
/*@egen*/
  BOTHSAEM() // Equals
| DIFFRINT()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ // Not Equals
}
void BOTHSAEM():{/*@bgen(jjtree) BOTHSAEM */
  SimpleNode jjtn000 = new SimpleNode(JJTBOTHSAEM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BOTHSAEM */
  try {
/*@egen*/
  <BOTH> <SAEM> Expression() (<AN>)? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
void DIFFRINT():{/*@bgen(jjtree) DIFFRINT */
  SimpleNode jjtn000 = new SimpleNode(JJTDIFFRINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DIFFRINT */
  try {
/*@egen*/
  <DIFFRINT> Expression() (<AN>)? Expression()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// vvv Flow Expressions vvv \\
void loop(): {/*@bgen(jjtree) loop */
  SimpleNode jjtn000 = new SimpleNode(JJTLOOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) loop */
  try {
/*@egen*/
  <IM><IN><YR> <LOOP_LABEL>//(<LOOP_OP> <YR> <IDENT> ((<TIL>|<WILE>) Expression() )?)?
     	Block()
  <IM><OUTTA><YR> <LOOP_LABEL>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ifThen():{/*@bgen(jjtree) ifThen */
  SimpleNode jjtn000 = new SimpleNode(JJTIFTHEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ifThen */
  try {
/*@egen*/
  < O_RLY ><QUESTION>
  	< YA_RLY >
  		Block()
    < NO_WAI >
    	Block()	
  < OIC >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
// ^^^ LOOP ^^^ \\

SKIP :
{
  " "
| <EOLIGNORE:<EOL>>
| < COMMENT : ("BTW" (~["\n"])* "\n") >
| "OBTW" : COMMENT_OPEN

//| < MULTI_LINE_COMMENT:        "OBTW" (~[<TLDR>])* <TLDR>        >
}

< COMMENT_OPEN > SKIP :
{
 "TLDR" : DEFAULT
}

< COMMENT_OPEN > MORE:
{
 < ~[] >
}


TOKEN :
{
  < HAI : "HAI" >
| < CAN : "CAN" >
| < HAS : "HAS" >
| < ITZ : "ITZ">
| < A : "A" >
| < I : "I" >
| < N : "N" >
| < IM : "IM" >
| < IN : "IN" >
| < IZ : "IZ" >
| < YR : "YR" >
| < UP : "UP" >
| < KTHX : "KTHX" >
| < KTHXBYE : "KTHXBYE" >
| < LOOP_LABEL : "LOOP" >
| < LOOP_OP : "UPPIN" | "NERFIN">
| < TROOF : "TROOF">
| < FAIL : "FAIL">
| < BOTH : "BOTH" >
| < EITHER : "EITHER" >
| < SAEM : "SAEM" >
| < DIFFRINT : "DIFFRINT" >
| < WON: "WON" >
| < NOT: "NOT" >
| < TIL : "TIL" >
| < WILE : "WILE" > 
| < THAN : "THAN" >
| < OUTTA : "OUTTA" >
| < BIGGER : "BIGGER" >
| < GIMMEH : "GIMMEH" >
| < PLZ : "PLZ" >
| < AWSUM_THX : "AWSUM THX" >
| < O_NOES : "O NOES" >
| < O_RLY : "O RLY" >
| < YA_RLY : "YA RLY" >
| < MEBBE : "MEBBE" >
| < NO_WAI : "NO WAI" >
| < OIC : "OIC" >
| < OPEN : "OPEN" >
| < QUESTION : "?" >
| < VISIBLE : "VISIBLE" >
| < INVISIBLE : "INVISIBLE" >
| < BANG : "!!" >
| < OF : "OF" >
| < AN : "AN" >
| < SUM : "SUM" >
| < DIFF : "DIFF" >
| < PRODUKT : "PRODUKT" >
| < QUOSHUNT : "QUOSHUNT" >
| < MOD : "MOD" >
| < BIGGR : "BIGGR" >
| < SMALLR : "SMALLR" >
| < QUOTED_STRING : "\"" (~["\""])+ "\"" >
| < INTEGER : ["1"-"9"] (["0"-"9"])* >
| < IDENT : (["A"-"Z"] | ["a"-"z"])+ >
| < EOL : "\n" | "\r" | "\r\n" >
| < TLDR : "TLDR">
}



