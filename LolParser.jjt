/**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **\
|   The_Almost_Donerz : CS 153 Compiler Design   |
|   				 Fall 2014                   |
\**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/

options
{
  VISITOR=false;
  MULTI=false;
  DEBUG_PARSER=true;
  JJTREE_OUTPUT_DIRECTORY="src/lolparser/frontend";
  NODE_EXTENDS="lolparser.intermediate.icodeimpl.ICodeNodeImpl";
  NODE_PACKAGE="lolparser.frontend";
}

PARSER_BEGIN(LolParser)
package lolparser.frontend;

import java.io.FileReader;
import java.io.FileNotFoundException;

import java.util.ArrayList;
import java.util.HashSet;

import lolparser.intermediate.*;
import lolparser.intermediate.icodeimpl.*;
import lolparser.intermediate.symtabimpl.*;
import lolparser.intermediate.symtabimpl.SymTabKeyImpl;
import lolparser.intermediate.typeimpl.*;
import lolparser.backend.*;
import lolparser.backend.compiler.*;
import lolparser.util.*;

public class LolParser
{
  private static SymTabStack symTabStack;
  private static SymTabEntry programId;
  
  public static void main(String args []) throws Exception
  {
	// Create and initialize the symbol table stack.
	symTabStack = SymTabFactory.createSymTabStack();
	//Predefined.initialize(symTabStack);
	
	SymTab variableList;
	int index = 0;
	variableList = SymTabFactory.createSymTab(1);
	ParseTreePrinter printer = new ParseTreePrinter(System.out);
	
    try
    {
	    if(args.length >= 1) {
	        System.out.println("Reading from file: " +args[0]);
	        new LolParser(new FileReader(args[0]));
	    } else {
	        System.out.println("Reading from standard input...");
	        new LolParser(System.in);
	    }
	} catch (FileNotFoundException fnfe) {
    	System.out.println(args[0] + " was not able to be found.");
	}

    try
    {
	  System.out.printf("/--- Parsing %s ---\\\n", args[0]);
	  SimpleNode n = LolParser.parse();
	  System.out.println("\\---Finished Parsing!---/");
	
	  // Create and initialize the ICode wrapper for the parse tree.
	  ICode iCode = ICodeFactory.createICode();
	  iCode.setRoot(n);
	  programId.setAttribute(SymTabKeyImpl.ROUTINE_ICODE, iCode);
	
	  // Print the cross-reference table.
	  CrossReferencer crossReferencer = new CrossReferencer();
	  crossReferencer.print(symTabStack);
	  
	  printer.print(symTabStack);
    }
    catch (ParseException pe)    {      pe.printStackTrace();    }
    
  }
}
PARSER_END(LolParser)

SimpleNode parse() : {SimpleNode rootNode;}
{
    Program_Header()
	rootNode = Block()
	< KTHXBYE >
	< EOF > { return rootNode;}
}

void Program_Header() #void : {}
{
	< HAI >
	  {
	    programId = symTabStack.enterLocal(token.image);
	    programId.setDefinition(DefinitionImpl.PROGRAM);
	    programId.setAttribute(SymTabKeyImpl.ROUTINE_SYMTAB, symTabStack.push());
	    symTabStack.setProgramId(programId);
	  }  }

SimpleNode Block() : {
  HashSet syncSet = new HashSet();
  syncSet.add(EOL);
  syncSet.add(KTHXBYE);
  syncSet.add(EOF);
}
{
  (LOOKAHEAD(2) Statement(syncSet))+
  { return jjtThis;}
}

void Statement(HashSet syncSet) #void:{}
{      AssignmentExpression(syncSet)	| FlowControlExpression() 	| LOOKAHEAD(2) (Declarations())	| FunctionCalls()	| ConstLiteralExpression()
	| SpecialOps()
	| Error()
}

void AssignmentExpression(HashSet syncSet):{}
{
 <IDENT > {
	SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("BAD VARIABLE ASSIGNMENT\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
  "R" Statement(syncSet)
}

void FlowControlExpression() #void:{}
{
  loop()
| ifThen()
}

void ConstLiteralExpression() #void:{}
{
  < QUOTED_STRING >
| < INTEGER >
}

void Declarations() #void : {}
{
  VarDeclareExpression()
| FunctionDeclare()}

void FunctionCalls() #void : {
  HashSet paramSyncSet = new HashSet();
  paramSyncSet.add(AN);
  paramSyncSet.add(MKAY);
}
{
  < I >< IZ >
  < IDENT > // Function name needs to go here
  [
  	< YR > Statement(paramSyncSet) (< AN >< YR > Statement(paramSyncSet))*
  ]
  < MKAY >}

void FunctionDeclare() : {}
{
  < HOW_IZ_I >
  Param() (< YR > Param())*
  Block()
  < IF_U_SAY_SO >}
void Param() #void : {}
{	< IDENT > // Must add to current symtable
}
void VarDeclareExpression() :
{
  int index = 0;
}
{
  	<I> <HAS> <A> <IDENT> {
	processVariableDecl(token, index++, symTabStack.getLocalSymTab());
	}
	(<ITZ> ConstLiteralExpression())?
//	(< EOL >)*
}

// vvv Arithemic Operations vvv \\
void ArithemticExpression() #void:{}
{
  SUM() 	// Add
| DIFF() 	// Subtract
| PRODUKT() // Product
| QUOSHUNT()// Quotient
| MOD() 	// Modulus
| BIGGR() 	// Max
| SMALLR() 	// Min
| UP()      // Increment
}
void SUM():  	// Add
{}
{
	<SUM> <OF> <INTEGER> <AN> <INTEGER>
}
void DIFF(): {} // Subtract
{
  <DIFF> <OF> <INTEGER> <AN> <INTEGER>	
}
void PRODUKT(): {} // Product
{
	<PRODUKT> <OF> <INTEGER> <AN> <INTEGER>
}
void QUOSHUNT(): {} // Quotient
{
  <QUOSHUNT> <OF> <INTEGER> <AN> <INTEGER>	
}
void MOD(): {} // Modulous
{
	<MOD> <OF> <INTEGER> <AN> <INTEGER>
}
void BIGGR(): {} // Max
{
	<BIGGR> <OF> <INTEGER> <AN> <INTEGER>
}
void SMALLR(): {} // Min
{
	<SMALLR> <OF> <INTEGER> <AN> <INTEGER>
}
void UP():{}
{
    <UP> <IDENT> <BANG> <INTEGER>
}
// ^^^ Arithemic Expressions ^^^ \\



// vvv Boolean Expressions vvv \\
void BooleanOperation():{
  HashSet boolOpSet = new HashSet();
  boolOpSet.add(AN);
  boolOpSet.add(EOL);
}
{
  BOTH(boolOpSet)   // And
| EITHER(boolOpSet) // Or
| WON(boolOpSet)    // Xor
| NOT(boolOpSet)    // Not	
}
void BOTH(HashSet syncSet):{} // And
{
  <BOTH> <OF> Statement(syncSet) (<AN>)? Statement(syncSet)
}
void EITHER(HashSet syncSet):{} // Or
{
  <EITHER> <OF> Statement(syncSet) (<AN>)? Statement(syncSet)
}
void WON(HashSet syncSet):{} // Xor
{
  <WON> <OF> Statement(syncSet) (<AN>)? Statement(syncSet)
}
void NOT(HashSet syncSet):{} // Not
{
  <NOT> Statement(syncSet)
}
// ^^^ Boolean Expressions ^^^ \\

void ComparisionOperation():{
  HashSet boolOpSet = new HashSet();
  boolOpSet.add(AN);
  boolOpSet.add(EOL);
}
{
  BOTHSAEM(boolOpSet) // Equals
| DIFFRINT(boolOpSet) // Not Equals
}
void BOTHSAEM(HashSet syncSet):{}
{
  <BOTH> <SAEM> Statement(syncSet) (<AN>)? Statement(syncSet)
}
void DIFFRINT(HashSet syncSet):{}
{
  <DIFFRINT> Statement(syncSet) (<AN>)? Statement(syncSet)
}

void SpecialOps() : {}
{	Increment()
|   Decrement()
|   ArithemticExpression()
|   LOOKAHEAD(2) (BooleanOperation())
|   ComparisionOperation()
}
void Increment() : {}
{	< UPPIN > < IDENT > 
}
void Decrement() : {}
{
	< NERFIN > < IDENT > 
}

// vvv Flow Expressions vvv \\
void loop(): {}
{
  <IM><IN><YR> <LOOP_LABEL>//(<LOOP_OP> <YR> <IDENT> ((<TIL>|<WILE>) Statement() )?)?
     	Block()
  <IM><OUTTA><YR> <LOOP_LABEL>
}

void ifThen():{}
{
  < O_RLY ><QUESTION>
  	< YA_RLY >
  		Block()
    < NO_WAI >
    	Block()	
  < OIC >
}
// ^^^ LOOP ^^^ \\

void Error() #void : {}
{
     <ERROR>
}

SKIP :
{
  " "
| < COMMENT : ("BTW" (~["\n"])* "\n") >
| "OBTW" : COMMENT_OPEN
| "\n" | "\r" | "\r\n"

//| < MULTI_LINE_COMMENT:        "OBTW" (~[<TLDR>])* <TLDR>        >
}

< COMMENT_OPEN > SKIP :
{
 "TLDR" : DEFAULT
}

< COMMENT_OPEN > MORE:
{
 < ~[] >
}


TOKEN :
{
  < HAI : "HAI" >
| < CAN : "CAN" >
| < HAS : "HAS" >
| < ITZ : "ITZ">
| < A : "A" >
| < I : "I" >
| < N : "N" >
| < IM : "IM" >
| < IN : "IN" >
| < IZ : "IZ" >
| < YR : "YR" >
| < UP : "UP">
| < UPPIN : "UPPIN" >
| < NERFIN : "NERFIN" >
| < KTHX : "KTHX" >
| < KTHXBYE : "KTHXBYE" >
| < LOOP_LABEL : "LOOP" >
| < LOOP_OP : "UPPIN" | "NERFIN">
| < TROOF : "TROOF">
| < FAIL : "FAIL">
| < BOTH : "BOTH" >
| < EITHER : "EITHER" >
| < SAEM : "SAEM" >
| < DIFFRINT : "DIFFRINT" >
| < WON: "WON" >
| < NOT: "NOT" >
| < TIL : "TIL" >
| < WILE : "WILE" > 
| < THAN : "THAN" >
| < OUTTA : "OUTTA" >
| < BIGGER : "BIGGER" >
| < GIMMEH : "GIMMEH" >
| < PLZ : "PLZ" >
| < AWSUM_THX : "AWSUM THX" >
| < O_NOES : "O NOES" >
| < O_RLY : "O RLY" >
| < YA_RLY : "YA RLY" >
| < MEBBE : "MEBBE" >
| < NO_WAI : "NO WAI" >
| < OIC : "OIC" >
| < OPEN : "OPEN" >
| < QUESTION : "?" >
| < VISIBLE : "VISIBLE" >
| < INVISIBLE : "INVISIBLE" >
| < IF_U_SAY_SO : "IF U SAY SO" >
| < HOW_IZ_I : "HOW IZ I" >
| < BANG : "!!" >
| < OF : "OF" >
| < AN : "AN" >
| < SUM : "SUM" >
| < DIFF : "DIFF" >
| < PRODUKT : "PRODUKT" >
| < QUOSHUNT : "QUOSHUNT" >
| < MOD : "MOD" >
| < BIGGR : "BIGGR" >
| < SMALLR : "SMALLR" >
| < QUOTED_STRING : "\"" (~["\""])+ "\"" >
| < INTEGER : ["1"-"9"] (["0"-"9"])* >
| < TLDR : "TLDR">
| < MKAY : "MKAY">
| < IDENT : (["A"-"Z"] | ["a"-"z"])+ >
//| < EOL : "\n" | "\r" | "\r\n" >
}

TOKEN : /* EOL */
{
//  < END_OF_BLOCK://      < IF_U_SAY_SO >//   | (<IM><OUTTA><YR><LOOP_LABEL>) //  > |
 < EOL : // either newline or comma    < HARD_EOL > // newline  | < SOFT_EOL >> // comma
| < #HARD_EOL : "\n" | "\r" | "\r\n" >
| < #SOFT_EOL : (",") >
}

TOKEN :
{	< ERROR : ~["\r", "\n"] >
}
JAVACODE
void processVariableDecl(Token token, int index,
                         SymTab variableList) #void
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
//    variableList.enter(token.image);
}

JAVACODE
String handleError(ParseException pe, HashSet syncSet) #void
{
  Token token = pe.currentToken;
  System.out.println(pe.getMessage());

  while(!syncSet.contains(getToken(1).kind))	token = getNextToken();


  return token.image;
}
