/**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **\|   The_Almost_Donerz : CS 153 Compiler Design   ||   				 Fall 2014                   |\**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/options{  VISITOR = true;  MULTI = true;  DEBUG_PARSER = true;  DEBUG_TOKEN_MANAGER = true;  JJTREE_OUTPUT_DIRECTORY = "src/lolparser/frontend";  NODE_EXTENDS = "lolparser.intermediate.icodeimpl.ICodeNodeImpl";  NODE_PACKAGE = "lolparser.frontend";}PARSER_BEGIN(LolParser)package lolparser.frontend;import java.io.FileReader;import java.io.FileNotFoundException;import java.util.ArrayList;import java.util.HashSet;import lolparser.intermediate.*;import lolparser.intermediate.icodeimpl.*;import lolparser.intermediate.symtabimpl.*;import lolparser.intermediate.symtabimpl.SymTabKeyImpl;import lolparser.intermediate.typeimpl.*;import lolparser.backend.*;import lolparser.backend.compiler.*;import lolparser.util.*;public class LolParser{  private static SymTabStack symTabStack;  private static SymTabEntry programId;  private static int index = 1; // 0 for this  private static HashSet syncSet;  private static int nestingLevel;  private static int variableIndex;  private static final String SOURCE_SUFFIX = ".lol";  private static final String OUTPUT_SUFFIX = ".j";  public static void main(String args []) throws Exception  {    Backend zehBackend = BackendFactory.createBackend("compile");    ParseTreePrinter printer = new ParseTreePrinter(System.out);    symTabStack = SymTabFactory.createSymTabStack();    Predefined.initialize(symTabStack);    SymTab variableList = SymTabFactory.createSymTab(0);    String objectFilePath = null;    try    {      if (args.length >= 1)      {        System.out.println("Reading from file: " + args [0]);        new LolParser(new FileReader(args [0]));        String sourceFilePath = args [0];        int truncatedLength = sourceFilePath.length() - SOURCE_SUFFIX.length();        int suffixIndex = sourceFilePath.lastIndexOf(SOURCE_SUFFIX);        objectFilePath = (suffixIndex == truncatedLength)         ? sourceFilePath.substring(0, truncatedLength) + OUTPUT_SUFFIX         : sourceFilePath + OUTPUT_SUFFIX;      }      else      {        System.out.println("Reading from standard input...");        new LolParser(System.in);      }    }    catch (FileNotFoundException fnfe)    {      System.out.println(args [0] + " was not able to be found.");    }    // Parse our lol    SimpleNode n = LolParser.parse();    // Create and initialize the ICode wrapper for the parse tree.    ICode iCode = ICodeFactory.createICode();    iCode.setRoot(n);    programId.setAttribute(SymTabKeyImpl.ROUTINE_ICODE, iCode);    // Print the cross-reference table.    CrossReferencer crossReferencer = new CrossReferencer();    crossReferencer.print(symTabStack);    printer.print(symTabStack);    // Generate Code    if (objectFilePath == null)    {      System.err.println("Invalid path for the jasmin file! Outputing to out.j ...");      zehBackend.process(iCode, symTabStack, "out.j");    }    else    {      zehBackend.process(iCode, symTabStack, objectFilePath);    }    // Generate code for function defs    ArrayList < SymTabEntry > symTabEntries = (ArrayList < SymTabEntry >) programId.getAttribute(SymTabKeyImpl.ROUTINE_ROUTINES);    for (SymTabEntry symTab : symTabEntries)    {      iCode = (ICode) symTab.getAttribute(SymTabKeyImpl.ROUTINE_ICODE);      zehBackend.processFunction(iCode, symTabStack, objectFilePath, symTab);    }  }  public static void printCaller()  {    StackTraceElement [] stackTraceElements = Thread.currentThread().getStackTrace();    System.out.println(stackTraceElements [2].getMethodName());  }}PARSER_END(LolParser)SimpleNode parse() :{  SimpleNode rootNode;}{  try  {    Program_Header()     rootNode = Block()    {      programId.setAttribute(SymTabKeyImpl.ROUTINE_LOCALS_COUNT, index);    }    Program_Ender()    {      return rootNode;    }  }  catch (ParseException pe)  {    handleError(pe, syncSet, false);  }}void Program_Header() #void :{  printCaller();}{  < HAI >  {    programId = symTabStack.enterLocal(token.image);    programId.setDefinition(DefinitionImpl.PROGRAM);    programId.setAttribute(SymTabKeyImpl.ROUTINE_SYMTAB, symTabStack.push());    programId.setAttribute(SymTabKeyImpl.ROUTINE_ROUTINES, new ArrayList < SymTabEntry > ());    symTabStack.setProgramId(programId);  }}void Program_Ender() #void :{  printCaller();}{  < KTHXBYE > < EOF >}SimpleNode Block() :{  syncSet = new HashSet();  syncSet.add(EOL);  syncSet.add(KTHXBYE);  syncSet.add(EOF);}{  (    LOOKAHEAD(2)    Statement(syncSet)  )+  {    return jjtThis;  }}void Statement(HashSet syncSet) #void :{}{  FlowControlExpression()| ConstLiteralExpression()| AssignmentExpression(syncSet)| LOOKAHEAD(2)  (    FunctionCalls()  )| LOOKAHEAD(2)  (    Declarations()  )| LOL_STD_OPS(syncSet)| Error()}void Expression(HashSet syncSet) #void :{}{  ConstLiteralExpression()| variable()  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED VARIABLE\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  }| Error()}void AssignmentExpression(HashSet syncSet) #Assign :{}{  variable()  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED VARIABLE\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  }  "R" Statement(syncSet)}void FlowControlExpression() #void :{}{  loop()| ifThen()}void ConstLiteralExpression() #Const :{}{  < QUOTED_STRING >  {    jjtThis.setTypeSpec(Predefined.charType);    jjtThis.setAttribute(ICodeKeyImpl.VALUE, token.image);  }| < INTEGER >  {    jjtThis.setTypeSpec(Predefined.integerType);    jjtThis.setAttribute(ICodeKeyImpl.VALUE, Integer.parseInt(token.image));  }| < NUMBAR >  {    jjtThis.setTypeSpec(Predefined.realType);    jjtThis.setAttribute(ICodeKeyImpl.VALUE, Float.parseFloat(token.image));  }| < TROOF >  {    jjtThis.setTypeSpec(Predefined.booleanType);    if (token.image.equals("WIN"))        jjtThis.setAttribute(ICodeKeyImpl.VALUE, "true");    else        jjtThis.setAttribute(ICodeKeyImpl.VALUE, "false");  }}void Declarations() #void :{}{  VarDeclareExpression()| FunctionDeclare()}void FunctionCalls() #FunctionCall :{  HashSet paramSyncSet = new HashSet();  syncSet = paramSyncSet;  paramSyncSet.add(AN);  paramSyncSet.add(MKAY);}{  < I > < IZ >   < IDENT >  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED FUNCTION\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  } // Function name needs to go here  [    < YR > Statement(paramSyncSet)    (      < AN > < YR > Statement(paramSyncSet)    )*  ]  < MKAY >}void FunctionDeclare() #FunctionDef :{  SymTabEntry funcEntry;  SymTab functionScope;  int currentVarIndex = variableIndex;}{  < HOW_IZ_I >   < IDENT >  {    funcEntry = symTabStack.enterLocal(token.image);    funcEntry.setDefinition(DefinitionImpl.FUNCTION);    functionScope = symTabStack.push();    funcEntry.setAttribute(SymTabKeyImpl.ROUTINE_SYMTAB, functionScope);    funcEntry.appendLineNumber(token.beginLine);    variableIndex = 0;  }  (    < YR > < IDENT >    {      processVariableDecl(token, variableIndex++, functionScope);    }  )*  Block()   < IF_U_SAY_SO >  {    symTabStack.pop();    variableIndex = currentVarIndex;  }}void VarDeclareExpression() #VariableDef :{}{  < I > < HAS > < A > variable()  {    processVariableDecl(token, variableIndex++, symTabStack.getLocalSymTab());    jjtThis.setTypeSpec(Predefined.undefinedType);    jjtThis.setAttribute(ICodeKeyImpl.VALUE, token.image);  }  (    < ITZ > ConstLiteralExpression()  )?}// vvv Arithemic Operations vvv \\void ArithemticExpression(HashSet syncSet) #void :{}{  SUM() // Add| DIFF() // Subtract| PRODUKT() // Product| QUOSHUNT() // Quotient| MOD() // Modulus| BIGGR() // Max| SMALLR() // Min| UP() // Increment}void SUM() #Add : // Add{}{  < SUM > < OF > Expression(syncSet) < AN > Expression(syncSet)}void DIFF() #Subtract :{} // Subtract{  < DIFF > < OF > Expression(syncSet) < AN > Expression(syncSet)}void PRODUKT() #Multiply :{} // Product{  < PRODUKT > < OF > Expression(syncSet) < AN > Expression(syncSet)}void QUOSHUNT() #Divide :{} // Quotient{  < QUOSHUNT > < OF > Expression(syncSet) < AN > Expression(syncSet)}void MOD() #Modulus :{} // Modulous{  < MOD > < OF > Expression(syncSet) < AN > Expression(syncSet)}void BIGGR() #Max :{} // Max{  < BIGGR > < OF > Expression(syncSet) < AN > Expression(syncSet)}void SMALLR() #Min :{} // Min{  < SMALLR > < OF > Expression(syncSet) < AN > Expression(syncSet)}void UP() #IncrementByInt :{}{  < UP > variable()  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED VARIABLE\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  }  < BANG > Expression(syncSet)}// ^^^ Arithemic Expressions ^^^ \\void BoolComparisonOperation() #void :{}{  LOOKAHEAD(2)  (    ComparisonOperation()  )| BooleanOperation()}// vvv Boolean Expressions vvv \\void BooleanOperation() #void :{  HashSet boolOpSet = new HashSet();  syncSet = boolOpSet;  boolOpSet.add(AN);  boolOpSet.add(EOL);}{  BOTH(boolOpSet) // And| EITHER(boolOpSet) // Or| WON(boolOpSet) // Xor| NOT(boolOpSet) // Not}void BOTH(HashSet syncSet) #And :{} // And{  < BOTH > < OF > Expression(syncSet) (< AN >)? Expression(syncSet)}void EITHER(HashSet syncSet) #Or :{} // Or{  < EITHER > < OF > Expression(syncSet) (< AN >)? Expression(syncSet)}void WON(HashSet syncSet) #Xor :{} // Xor{  < WON > < OF > Expression(syncSet) (< AN >)? Expression(syncSet)}void NOT(HashSet syncSet) #Not :{} // Not{  < NOT > Expression(syncSet)}// ^^^ Boolean Expressions ^^^ \\void ComparisonOperation() #void :{  HashSet boolOpSet = new HashSet();  syncSet = boolOpSet;  boolOpSet.add(AN);  boolOpSet.add(EOL);}{  BOTHSAEM(boolOpSet) // Equals| DIFFRINT(boolOpSet) // Not Equals}void BOTHSAEM(HashSet syncSet) #Equals :{}{  < BOTH > < SAEM >  (    Expression(syncSet)  )  (< AN >)?  (    Expression(syncSet)  )}void DIFFRINT(HashSet syncSet) #NotEquals :{}{  < DIFFRINT >  (    Expression(syncSet)  )  (< AN >)?  (    Expression(syncSet)  )}void LOL_STD_OPS(HashSet hashSet) :{}{  Increment()| Decrement()| Break()| ArithemticExpression(hashSet)| BoolComparisonOperation()| StdOut(hashSet)| StdIn()}void Increment() #Increment :{}{  < UPPIN > variable()  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED VARIABLE\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  }}void Decrement() #Decrement :{}{  < NERFIN > variable()  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED VARIABLE\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  }}void Break() #void :{}{  < GTFO : "GTFO" >}void StdOut(HashSet hs) #StdOut :{}{  < VISIBLE >  (    ConstLiteralExpression()  | variable()    {      SymTabEntry variableId = symTabStack.lookup(token.image);      if (variableId == null)      {        System.err.print("UNDECLARED VARIABLE\n");      }      else      {        variableId.appendLineNumber(token.beginLine);      }    }  )}void StdIn() #StdIn :{}{  < GIMMEH > variable()  {    SymTabEntry variableId = symTabStack.lookup(token.image);    if (variableId == null)    {      System.err.print("UNDECLARED VARIABLE\n");    }    else    {      variableId.appendLineNumber(token.beginLine);    }  }}void loop() #Loop :{}{  < IM > < IN > < YR > < LOOP_LABEL >  (    LOOKAHEAD(2)    (      < UPPIN >    | < NERFIN >    )    < YR > variable()    {      SymTabEntry variableId = symTabStack.lookup(token.image);      if (variableId == null)      {        System.err.print("UNDECLARED VARIABLE\n");      }      else      {        variableId.appendLineNumber(token.beginLine);      }    }    (      (        < TIL >      | < WILE >      )      BoolComparisonOperation()    )?  )?  Block()   < IM > < OUTTA > < YR > < LOOP_LABEL >}void ifThen() #If :{}{  < O_RLY > < QUESTION >   IfBlock()   < OIC >}void IfBlock() #IfBlock :{}{  (    BoolComparisonOperation()  | < TROOF >  )  < YA_RLY >   Block()  (    < MEBBE >    (      BoolComparisonOperation()    | < TROOF >    )    Block()  )*  (    < NO_WAI >     Block()  )?}void variable() #Ident :{}{  < IDENT >  {    jjtThis.setTypeSpec(Predefined.undefinedType);    jjtThis.setAttribute(ICodeKeyImpl.VALUE, token.image);  }}void Error() #void :{}{  < ERROR >}SKIP :{  " "| < COMMENT :    (      "BTW" (~[ "\n" ])* "\n"    ) >| "OBTW" : COMMENT_OPEN| "\n"| "\r"| "\r\n"| "\t"  //| < MULTI_LINE_COMMENT:        "OBTW" (~[<TLDR>])* <TLDR>        >}< COMMENT_OPEN >SKIP :{  "TLDR" : DEFAULT}< COMMENT_OPEN >MORE :{  < ~[ ] >}TOKEN :{  < HAI : "HAI" >| < CAN : "CAN" >| < HAS : "HAS" >| < ITZ : "ITZ" >| < A : "A" >| < I : "I" >| < N : "N" >| < IM : "IM" >| < IN : "IN" >| < IZ : "IZ" >| < YR : "YR" >| < UP : "UP" >| < UPPIN : "UPPIN" >| < NERFIN : "NERFIN" >| < KTHX : "KTHX" >| < KTHXBYE : "KTHXBYE" >| < LOOP_LABEL : "LOOP" >| < LOOP_OP :    "UPPIN"  | "NERFIN" >| < TROOF :    < WIN >  | < FAIL >>| < #FAIL : "FAIL" >| < #WIN : "WIN" >| < BOTH : "BOTH" >| < EITHER : "EITHER" >| < SAEM : "SAEM" >| < DIFFRINT : "DIFFRINT" >| < WON : "WON" >| < NOT : "NOT" >| < TIL : "TIL" >| < WILE : "WILE" >| < THAN : "THAN" >| < OUTTA : "OUTTA" >| < BIGGER : "BIGGER" >| < GIMMEH : "GIMMEH" >| < PLZ : "PLZ" >| < AWSUM_THX : "AWSUM THX" >| < O_NOES : "O NOES" >| < O_RLY : "O RLY" >| < YA_RLY : "YA RLY" >| < MEBBE : "MEBBE" >| < NO_WAI : "NO WAI" >| < OIC : "OIC" >| < OPEN : "OPEN" >| < QUESTION : "?" >| < VISIBLE : "VISIBLE" >| < INVISIBLE : "INVISIBLE" >| < IF_U_SAY_SO : "IF U SAY SO" >| < HOW_IZ_I : "HOW IZ I" >| < BANG : "!!" >| < OF : "OF" >| < AN : "AN" >| < SUM : "SUM" >| < DIFF : "DIFF" >| < PRODUKT : "PRODUKT" >| < QUOSHUNT : "QUOSHUNT" >| < MOD : "MOD" >| < BIGGR : "BIGGR" >| < SMALLR : "SMALLR" >| < QUOTED_STRING : "\"" (~[ "\"" ])+ "\"" >| < INTEGER :    (      [ "1"-"9" ] (< DIGITS >)*    )  | ("0") >| < NUMBAR : < REAL >>| < #REAL : (< INTEGER >)? "." (< DIGITS >)+ >| < #DIGITS : [ "0"-"9" ] >| < TLDR : "TLDR" >| < MKAY : "MKAY" >| < IDENT :    (      [ "A"-"Z" ]    | [ "a"-"z" ]    | [ "_" ]    )+ >  //| < EOL : "\n" | "\r" | "\r\n" >}TOKEN : /* EOL */{  //  < END_OF_BLOCK:  //      < IF_U_SAY_SO >  //   | (<IM><OUTTA><YR><LOOP_LABEL>)   //  > |  < EOL : // either newline or comma    < HARD_EOL > // newline  | < SOFT_EOL >> // comma| < #HARD_EOL :    "\n"  | "\r"  | "\r\n" >| < #SOFT_EOL : (",") >}TOKEN :{  < ERROR : ~[ "\r", "\n" ] >}JAVACODE void processVariableDecl(Token token, int index, SymTab variableList) #void{  SymTabEntry variableId = variableList.enter(token.image);variableId.setIndex(index);variableId.setDefinition(DefinitionImpl.VARIABLE);variableId.appendLineNumber(token.beginLine);}JAVACODE String handleError(ParseException ex, HashSet syncSet, boolean doPop) #void{  Token token = ex.currentToken;  System.out.println(ex.getMessage());// Consume tokens up to but not including a token in the sync set.while(  !syncSet.contains(token.kind)){  token = getNextToken();}if (doPop) jjtree.popNode();return token.image;}