/**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **\
|   The_Almost_Donerz : CS 153 Compiler Design   |
|   				 Fall 2014                   |
\**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/

options
{
  VISITOR=false;
  MULTI=false;
  DEBUG_PARSER=false;
  JJTREE_OUTPUT_DIRECTORY="src/lolparser/frontend";
  NODE_EXTENDS="lolparser.intermediate.icodeimpl.ICodeNodeImpl";
  NODE_PACKAGE="lolparser.frontend";
}

PARSER_BEGIN(LolParser)
package lolparser.frontend;

import java.io.FileReader;
import java.io.FileNotFoundException;

import java.util.ArrayList;
import java.io.*;

import lolparser.intermediate.*;
import lolparser.intermediate.symtabimpl.*;
import lolparser.backend.*;
import lolparser.util.*;

import static lolparser.intermediate.symtabimpl.SymTabKeyImpl.*;
import static lolparser.intermediate.symtabimpl.DefinitionImpl.*;
import static lolparser.intermediate.symtabimpl.RoutineCodeImpl.*;
import static lolparser.intermediate.symtabimpl.SymTabKeyImpl.*;
import static lolparser.intermediate.icodeimpl.ICodeKeyImpl.*;

public class LolParser
{

    private static SymTabStack symTabStack;
    private static SymTabEntry programId;
  
  public static void main(String args []) throws Exception
  {
		// Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        //Predefined.initialize(symTabStack);

        SymTab variableList;
	    int index = 0;
    	variableList = SymTabFactory.createSymTab(1);
    
    try
    {  
	    if(args.length >= 1) {
			System.out.println("Reading from file: " +args[0]);
			new LolParser(new FileReader(args[0]));
	    } else {
			System.out.println("Reading from standard input...");
			new LolParser(System.in);
	    }
	} catch (FileNotFoundException fnfe) {
		System.out.println(args[0] + " was not able to be found.");
	}
    
    try
    {
      System.out.printf("/--- Parsing %s ---\\\n", args[0]); 
      SimpleNode n = LolParser.parse();
      n.dump("");
      System.out.println("---Finished Parsing!---");
    }
    catch (ParseException pe)    {
      pe.printStackTrace();    }
    catch (Exception e)
    {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
      e.printStackTrace();
    }
  }
}
PARSER_END(LolParser)

SimpleNode parse() :{}
{
  < HAI >(<EOL>)*
   (Statement())*
  < KTHXBYE > (<EOL>)*
  < EOF >
  { return jjtThis;}
}
void Block() #void:{}
{
 (LOOKAHEAD(2) Statement())+
 (< EOL >)*
}

void Statement()#void:{}
{
  Expression() 
}
void Expression() #void:{}
{
  AssignmentExpression()
| FlowControlExpression() 
| ArithemticExpression()
| VarDeclareExpression()
| ConstLiteralExpression()
}

//void OperationExpression() :{Token t;}//{//  t=Operator()//  (//    Expression()//  | Expression() < AN > Expression()//  | Expression() (< AN > Expression())+ < MKAY > //  ) //}////void Operator() :{}//{//  //Insert operator syntax rules//  ArithemticExpression()//}
  
void ConstLiteralExpression() #void:{}
{
  < QUOTED_STRING >
| < INTEGER >
}

void AssignmentExpression():{}
{
 <IDENT > {	SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)	{
	  System.err.print("BAD VARIABLE ASSIGNMENT\n");    } else    {      variableId.appendLineNumber(token.beginLine);
    }
  }
  "R" Expression() 
}

void VarDeclareExpression() :
{
  int index = 0;
}
{
  try  {  	<I> <HAS> <A> <IDENT> {
	processVariableDecl(token, index++, symTabStack.getLocalSymTab());
	}
	(<ITZ> ConstLiteralExpression())?
  }
  catch (ParseException pe)  {	handleError(pe);
  }
}

void FlowControlExpression() #void:{}
{
  loop()
| ifThen()
}

// vvv Arithemic Operations vvv \\
void ArithemticExpression() #void:{}
{
  SUM() 	// Add
| DIFF() 	// Subtract
| PRODUKT() // Product
| QUOSHUNT()// Quotient
| MOD() 	// Modulus
| BIGGR() 	// Max
| SMALLR() 	// Min
| UP()      // Increment
}
void SUM():  	// Add
{}
{
	<SUM> <OF> <INTEGER> <AN> <INTEGER>
}
void DIFF(): {} // Subtract
{
  <DIFF> <OF> <INTEGER> <AN> <INTEGER>	
}
void PRODUKT(): {} // Product
{
	<PRODUKT> <OF> <INTEGER> <AN> <INTEGER>
}
void QUOSHUNT(): {} // Quotient
{
  <QUOSHUNT> <OF> <INTEGER> <AN> <INTEGER>	
}
void MOD(): {} // Modulous
{
	<MOD> <OF> <INTEGER> <AN> <INTEGER>
}
void BIGGR(): {} // Max
{
	<BIGGR> <OF> <INTEGER> <AN> <INTEGER>
}
void SMALLR(): {} // Min
{
	<SMALLR> <OF> <INTEGER> <AN> <INTEGER>
}
void UP():{}
{
    <UP> <IDENT> <BANG> <INTEGER>
}
// ^^^ Arithemic Expressions ^^^ \\



// vvv Boolean Expressions vvv \\
void BooleanOperation():{}
{
  BOTH()   // And
| EITHER() // Or
| WON()    // Xor
| NOT()    // Not	
}
void BOTH():{} // And
{
  <BOTH> <OF> Expression() (<AN>)? Expression()
}
void EITHER():{} // Or
{
  <EITHER> <OF> Expression() (<AN>)? Expression()
}
void WON():{} // Xor
{
  <WON> <OF> Expression() (<AN>)? Expression()
}
void NOT():{} // Not
{
  <NOT> Expression()
}
// ^^^ Boolean Expressions ^^^ \\

void ComparisionOperation():{}
{
  BOTHSAEM() // Equals
| DIFFRINT() // Not Equals
}
void BOTHSAEM():{}
{
  <BOTH> <SAEM> Expression() (<AN>)? Expression()
}
void DIFFRINT():{}
{
  <DIFFRINT> Expression() (<AN>)? Expression()
}

// vvv Flow Expressions vvv \\
void loop(): {}
{
  <IM><IN><YR> <LOOP_LABEL>//(<LOOP_OP> <YR> <IDENT> ((<TIL>|<WILE>) Expression() )?)?
     	Block()
  <IM><OUTTA><YR> <LOOP_LABEL>
}

void ifThen():{}
{
  < O_RLY ><QUESTION>
  	< YA_RLY >
  		Block()
    < NO_WAI >
    	Block()	
  < OIC >
}
// ^^^ LOOP ^^^ \\

SKIP :
{
  " "
| <EOLIGNORE:<EOL>>
| < COMMENT : ("BTW" (~["\n"])* "\n") >
| "OBTW" : COMMENT_OPEN

//| < MULTI_LINE_COMMENT:        "OBTW" (~[<TLDR>])* <TLDR>        >
}

< COMMENT_OPEN > SKIP :
{
 "TLDR" : DEFAULT
}

< COMMENT_OPEN > MORE:
{
 < ~[] >
}


TOKEN :
{
  < HAI : "HAI" >
| < CAN : "CAN" >
| < HAS : "HAS" >
| < ITZ : "ITZ">
| < A : "A" >
| < I : "I" >
| < N : "N" >
| < IM : "IM" >
| < IN : "IN" >
| < IZ : "IZ" >
| < YR : "YR" >
| < UP : "UP" >
| < KTHX : "KTHX" >
| < KTHXBYE : "KTHXBYE" >
| < LOOP_LABEL : "LOOP" >
| < LOOP_OP : "UPPIN" | "NERFIN">
| < TROOF : "TROOF">
| < FAIL : "FAIL">
| < BOTH : "BOTH" >
| < EITHER : "EITHER" >
| < SAEM : "SAEM" >
| < DIFFRINT : "DIFFRINT" >
| < WON: "WON" >
| < NOT: "NOT" >
| < TIL : "TIL" >
| < WILE : "WILE" > 
| < THAN : "THAN" >
| < OUTTA : "OUTTA" >
| < BIGGER : "BIGGER" >
| < GIMMEH : "GIMMEH" >
| < PLZ : "PLZ" >
| < AWSUM_THX : "AWSUM THX" >
| < O_NOES : "O NOES" >
| < O_RLY : "O RLY" >
| < YA_RLY : "YA RLY" >
| < MEBBE : "MEBBE" >
| < NO_WAI : "NO WAI" >
| < OIC : "OIC" >
| < OPEN : "OPEN" >
| < QUESTION : "?" >
| < VISIBLE : "VISIBLE" >
| < INVISIBLE : "INVISIBLE" >
| < BANG : "!!" >
| < OF : "OF" >
| < AN : "AN" >
| < SUM : "SUM" >
| < DIFF : "DIFF" >
| < PRODUKT : "PRODUKT" >
| < QUOSHUNT : "QUOSHUNT" >
| < MOD : "MOD" >
| < BIGGR : "BIGGR" >
| < SMALLR : "SMALLR" >
| < QUOTED_STRING : "\"" (~["\""])+ "\"" >
| < INTEGER : ["1"-"9"] (["0"-"9"])* >
| < IDENT : (["A"-"Z"] | ["a"-"z"])+ >
| < EOL : "\n" | "\r" | "\r\n" >
| < TLDR : "TLDR">
}

JAVACODE
void processVariableDecl(Token token, int index,
                         SymTab variableList) #void
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
    variableList.enter(token.image);
}

JAVACODE
String handleError(ParseException ex) #void
{
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    do {
    	token = getNextToken();
    } while (token.kind != EOL);

	jjtree.popNode();
    return token.image;
}