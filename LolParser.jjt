/**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **\
|   The_Almost_Donerz : CS 153 Compiler Design   |
|   				 Fall 2014                   |
\**  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **/

options
{
  VISITOR=true;
  MULTI=true;
  DEBUG_PARSER=true;
  JJTREE_OUTPUT_DIRECTORY="src/lolparser/frontend";
  NODE_EXTENDS="lolparser.intermediate.icodeimpl.ICodeNodeImpl";
  NODE_PACKAGE="lolparser.frontend";
}

PARSER_BEGIN(LolParser)
package lolparser.frontend;

import java.io.FileReader;
import java.io.FileNotFoundException;

import java.util.ArrayList;
import java.util.HashSet;

import lolparser.intermediate.*;
import lolparser.intermediate.icodeimpl.*;
import lolparser.intermediate.symtabimpl.*;
import lolparser.intermediate.symtabimpl.SymTabKeyImpl;
import lolparser.intermediate.typeimpl.*;
import lolparser.backend.*;
import lolparser.backend.compiler.*;
import lolparser.util.*;

public class LolParser
{
  private static SymTabStack symTabStack;
  private static SymTabEntry programId;
  private static HashSet syncSet;
  
  public static void main(String args []) throws Exception
  {
	// Create and initialize the symbol table stack.
	symTabStack = SymTabFactory.createSymTabStack();
	//Predefined.initialize(symTabStack);
	
	SymTab variableList;
	int index = 0;
	variableList = SymTabFactory.createSymTab(1);
	ParseTreePrinter printer = new ParseTreePrinter(System.out);
	
    try
    {
	    if(args.length >= 1) {
	        System.out.println("Reading from file: " +args[0]);
	        new LolParser(new FileReader(args[0]));
	    } else {
	        System.out.println("Reading from standard input...");
	        new LolParser(System.in);
	    }
	} catch (FileNotFoundException fnfe) {
    	System.out.println(args[0] + " was not able to be found.");
	}

    try
    {
	  System.out.printf("/--- Parsing %s ---\\\n", args[0]);
	  SimpleNode n = LolParser.parse();
	  System.out.println("\\---Finished Parsing!---/");
	
	  // Create and initialize the ICode wrapper for the parse tree.
	  ICode iCode = ICodeFactory.createICode();
	  iCode.setRoot(n);
	  programId.setAttribute(SymTabKeyImpl.ROUTINE_ICODE, iCode);
	
	  // Print the cross-reference table.
	  CrossReferencer crossReferencer = new CrossReferencer();
	  crossReferencer.print(symTabStack);
	  
	  printer.print(symTabStack);
    }
    catch (ParseException pe)    {      handleError(pe, syncSet, false);     }
    
  }
}
PARSER_END(LolParser)

SimpleNode parse() : {SimpleNode rootNode;}
{
    Program_Header()
	rootNode = Block()
	< KTHXBYE >
	< EOF > { return rootNode;}
}

void Program_Header() #void : {}
{
	< HAI >
	  {
	    programId = symTabStack.enterLocal(token.image);
	    programId.setDefinition(DefinitionImpl.PROGRAM);
	    programId.setAttribute(SymTabKeyImpl.ROUTINE_SYMTAB, symTabStack.push());
	    symTabStack.setProgramId(programId);
	  }  }

SimpleNode Block() : {
  syncSet = new HashSet();
  syncSet.add(EOL);
  syncSet.add(KTHXBYE);
  syncSet.add(EOF);
}
{
  (LOOKAHEAD(2) Statement(syncSet))+
  { return jjtThis;}
}

void Statement(HashSet syncSet) #void:{}
{  FlowControlExpression()
| ConstLiteralExpression()
| AssignmentExpression(syncSet)
| LOOKAHEAD(2) (FunctionCalls()) | LOOKAHEAD(2) (Declarations())
| LOL_STD_OPS(syncSet)
| Error()
}

void Expression(HashSet syncSet) : {}
{
  ConstLiteralExpression()
| variable() {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
| Error()}

void AssignmentExpression(HashSet syncSet):{}
{
 variable()  {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  } "R" Statement(syncSet)
}

void FlowControlExpression() #void:{}
{
  loop()
| ifThen()
}

void ConstLiteralExpression() #void:{}
{
  < QUOTED_STRING >
| < INTEGER >
}

void Declarations() #void : {}
{
  VarDeclareExpression()
| FunctionDeclare()}

void FunctionCalls() #void : {
  HashSet paramSyncSet = new HashSet();
  syncSet = paramSyncSet;
  paramSyncSet.add(AN);
  paramSyncSet.add(MKAY);
}
{	    < I >< IZ >
	  < IDENT >   {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED FUNCTION\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }// Function name needs to go here
	  [
	  	< YR > Statement(paramSyncSet) (< AN >< YR > Statement(paramSyncSet))*
	  ]
	  < MKAY >}
void FunctionDeclare() : {
	int index = 0;
  }
{
  < HOW_IZ_I >
  < IDENT >  {
        SymTabEntry funcEntry = symTabStack.enterLocal(token.image);
        funcEntry.setDefinition(DefinitionImpl.FUNCTION);
        funcEntry.setAttribute(SymTabKeyImpl.ROUTINE_SYMTAB, symTabStack.push());
        funcEntry.appendLineNumber(token.beginLine);
    }
    (< YR > <IDENT>{
		processVariableDecl(token, index++, symTabStack.getLocalSymTab());
  	})*
  Block()
  < IF_U_SAY_SO >  {
    symTabStack.pop();  }
}

void VarDeclareExpression() :
{
  int index = 0;
}
{
  	<I> <HAS> <A> variable(){
		processVariableDecl(token, index++, symTabStack.getLocalSymTab());  	}
	(<ITZ> ConstLiteralExpression())?
//	(< EOL >)*
}

// vvv Arithemic Operations vvv \\
void ArithemticExpression(HashSet syncSet) #void:{}
{
  SUM() 	// Add
| DIFF() 	// Subtract
| PRODUKT() // Product
| QUOSHUNT()// Quotient
| MOD() 	// Modulus
| BIGGR() 	// Max
| SMALLR() 	// Min
| UP()      // Increment
}
void SUM():  	// Add
{}
{
	<SUM> <OF> Expression(syncSet) <AN> Expression(syncSet)
}
void DIFF(): {} // Subtract
{
  <DIFF> <OF> Expression(syncSet) <AN> Expression(syncSet)
}
void PRODUKT(): {} // Product
{
	<PRODUKT> <OF> Expression(syncSet) <AN> Expression(syncSet)
}
void QUOSHUNT(): {} // Quotient
{
  <QUOSHUNT> <OF> Expression(syncSet) <AN> Expression(syncSet)	
}
void MOD(): {} // Modulous
{
	<MOD> <OF> Expression(syncSet) <AN> Expression(syncSet)
}
void BIGGR(): {} // Max
{
	<BIGGR> <OF> Expression(syncSet) <AN> Expression(syncSet)
}
void SMALLR(): {} // Min
{
	<SMALLR> <OF> Expression(syncSet) <AN> Expression(syncSet)
}
void UP():{}
{
    <UP> variable() {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
  <BANG> Expression(syncSet)
}
// ^^^ Arithemic Expressions ^^^ \\

void BoolComparisonOperation():{}{
LOOKAHEAD(2) (ComparisonOperation())
| BooleanOperation()
}

// vvv Boolean Expressions vvv \\
void BooleanOperation():{
  HashSet boolOpSet = new HashSet();
  syncSet = boolOpSet;
  boolOpSet.add(AN);
  boolOpSet.add(EOL);
}
{
  BOTH(boolOpSet)   // And
| EITHER(boolOpSet) // Or
| WON(boolOpSet)    // Xor
| NOT(boolOpSet)    // Not
}
void BOTH(HashSet syncSet):{} // And
{
  <BOTH> <OF> Expression(syncSet) (<AN>)? Expression(syncSet)
}
void EITHER(HashSet syncSet):{} // Or
{
  <EITHER> <OF> Expression(syncSet) (<AN>)? Expression(syncSet)
}
void WON(HashSet syncSet):{} // Xor
{
  <WON> <OF> Expression(syncSet) (<AN>)? Expression(syncSet)
}
void NOT(HashSet syncSet):{} // Not
{
  <NOT> Expression(syncSet)
}
// ^^^ Boolean Expressions ^^^ \\

void ComparisonOperation():{
  HashSet boolOpSet = new HashSet();
  syncSet = boolOpSet;
  boolOpSet.add(AN);
  boolOpSet.add(EOL);
}
{
  BOTHSAEM(boolOpSet) // Equals
| DIFFRINT(boolOpSet) // Not Equals
}
void BOTHSAEM(HashSet syncSet):{}
{
  <BOTH> <SAEM> (Expression(syncSet)|<TROOF>) (<AN>)? (Expression(syncSet)|<TROOF>)
}
void DIFFRINT(HashSet syncSet):{}
{
  <DIFFRINT> (Expression(syncSet)|<TROOF>) (<AN>)? (Expression(syncSet)|<TROOF>)
}

void LOL_STD_OPS(HashSet hashSet) : {}
{	Increment()
|   Decrement()
|   Break()
|   ArithemticExpression(hashSet)
|   BoolComparisonOperation()
|   StdOut(hashSet)
| 	StdIn()
}
void Increment() : {}
{	< UPPIN > variable() {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
}
void Decrement() : {}
{
	< NERFIN > variable(){
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
}
void Break() #void : {}
{	< GTFO : "GTFO" >
}
void StdOut(HashSet hs) : {}
{
  < VISIBLE > (ConstLiteralExpression()| variable() {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
  | < TROOF >)}
void StdIn() :{}
{
  < GIMMEH > variable() {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }}

void loop(): {}
{
  <IM>  <IN> <YR> <LOOP_LABEL> (LOOKAHEAD(2) (<UPPIN>|<NERFIN>) <YR> variable() {
    SymTabEntry variableId = symTabStack.lookup(token.image);
	if(variableId == null)
	{
	  System.err.print("UNDECLARED VARIABLE\n");
    } else
    {
      variableId.appendLineNumber(token.beginLine);
    }
  }
  ((<TIL>|<WILE>) BoolComparisonOperation())? )?
  	Block()
  <IM><OUTTA><YR> <LOOP_LABEL>
}

void ifThen() #void :{}
{
  < O_RLY ><QUESTION>
  	IfBlock()
  < OIC >
}
void IfBlock() : {}
{
  (BoolComparisonOperation() | <TROOF>)
  < YA_RLY >
    Block()
    (< MEBBE > (BoolComparisonOperation() | <TROOF>)
    Block())*
 (< NO_WAI >
    Block() )?}

void variable():{}
{
  < IDENT >
}

void Error() #void : {}
{
     <ERROR>
}

SKIP :
{
  " "
| < COMMENT : ("BTW" (~["\n"])* "\n") >
| "OBTW" : COMMENT_OPEN
| "\n" | "\r" | "\r\n" | "\t"

//| < MULTI_LINE_COMMENT:        "OBTW" (~[<TLDR>])* <TLDR>        >
}

< COMMENT_OPEN > SKIP :
{
 "TLDR" : DEFAULT
}

< COMMENT_OPEN > MORE:
{
 < ~[] >
}


TOKEN :
{
  < HAI : "HAI" >
| < CAN : "CAN" >
| < HAS : "HAS" >
| < ITZ : "ITZ">
| < A : "A" >
| < I : "I" >
| < N : "N" >
| < IM : "IM" >
| < IN : "IN" >
| < IZ : "IZ" >
| < YR : "YR" >
| < UP : "UP">
| < UPPIN : "UPPIN" >
| < NERFIN : "NERFIN" >
| < KTHX : "KTHX" >
| < KTHXBYE : "KTHXBYE" >
| < LOOP_LABEL : "LOOP" >
| < LOOP_OP : "UPPIN" | "NERFIN">
| < TROOF : < WIN > | < FAIL >>
| < #FAIL : "FAIL">
| < #WIN : "WIN" >			
| < BOTH : "BOTH" >
| < EITHER : "EITHER" >
| < SAEM : "SAEM" >
| < DIFFRINT : "DIFFRINT" >
| < WON: "WON" >
| < NOT: "NOT" >
| < TIL : "TIL" >
| < WILE : "WILE" > 
| < THAN : "THAN" >
| < OUTTA : "OUTTA" >
| < BIGGER : "BIGGER" >
| < GIMMEH : "GIMMEH" >
| < PLZ : "PLZ" >
| < AWSUM_THX : "AWSUM THX" >
| < O_NOES : "O NOES" >
| < O_RLY : "O RLY" >
| < YA_RLY : "YA RLY" >
| < MEBBE : "MEBBE" >
| < NO_WAI : "NO WAI" >
| < OIC : "OIC" >
| < OPEN : "OPEN" >
| < QUESTION : "?" >
| < VISIBLE : "VISIBLE" >
| < INVISIBLE : "INVISIBLE" >
| < IF_U_SAY_SO : "IF U SAY SO" >
| < HOW_IZ_I : "HOW IZ I" >
| < BANG : "!!" >
| < OF : "OF" >
| < AN : "AN" >
| < SUM : "SUM" >
| < DIFF : "DIFF" >
| < PRODUKT : "PRODUKT" >
| < QUOSHUNT : "QUOSHUNT" >
| < MOD : "MOD" >
| < BIGGR : "BIGGR" >
| < SMALLR : "SMALLR" >
| < QUOTED_STRING : "\"" (~["\""])+ "\"" >
| < INTEGER : (["1"-"9"] (["0"-"9"])*)|("0") >
| < TLDR : "TLDR">
| < MKAY : "MKAY">
| < IDENT : (["A"-"Z"] | ["a"-"z"] | ["_"])+ >
//| < EOL : "\n" | "\r" | "\r\n" >
}

TOKEN : /* EOL */
{
//  < END_OF_BLOCK://      < IF_U_SAY_SO >//   | (<IM><OUTTA><YR><LOOP_LABEL>) //  > |
 < EOL : // either newline or comma    < HARD_EOL > // newline  | < SOFT_EOL >> // comma
| < #HARD_EOL : "\n" | "\r" | "\r\n" >
| < #SOFT_EOL : (",") >
}

TOKEN :
{	< ERROR : ~["\r", "\n"] >
}
JAVACODE
void processVariableDecl(Token token, int index,
                         SymTab variableList) #void
{
    SymTabEntry variableId = symTabStack.enterLocal(token.image);
    variableId.setIndex(index);
    variableId.setDefinition(DefinitionImpl.VARIABLE);
    variableId.appendLineNumber(token.beginLine);
}

JAVACODE
String handleError(ParseException ex, HashSet syncSet, boolean doPop) #void
{
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    // Consume tokens up to but not including a token in the sync set.
    while (!syncSet.contains(token.kind)) {
        token = getNextToken();
    } 	

    if (doPop) jjtree.popNode();
    return token.image;
}
